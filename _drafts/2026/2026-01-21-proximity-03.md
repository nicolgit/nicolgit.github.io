---
title: "Architectural decisions behind - The Proximity project"
date: 2026-01-21 10:00
tags: [opensource, the proximity project]
excerpt: "What seems simple â€” computing isochrones for transport stops â€” becomes an architectural puzzle at scale. Here's how deliberate trade-offs between performance, cost, and maintainability shaped The Proximity project's tech stack."

header:
  overlay_image: https://live.staticflickr.com/65535/54686110597_fa1ab73a10_h.jpg
  caption: "Photo credit: [**nicola since 1972**](https://www.flickr.com/photos/15216811@N06/54686110597)"
---

When I started building The Proximity project, the goal seemed simple: compute walking-distance isochrones for multiple transport stops and display them interactively.

As the project grew, scaling it across cities, transport types, and interactive maps forced deliberate architectural choices.

# Frontend
SPA with Vue and TypeScript:
* TypeScript helps catch errors at compile-time, making the codebase more robust and maintainable than plain JavaScript.
* Vue provides a reactive, component-based framework that is lightweight, easy to reason about, and ideal for building interactive map interfaces.

Maps with Leaflet:
* Leaflet is fast, flexible, and lightweight. It integrates well with tile-based rendering and supports vector overlays and heatmaps, which I use to show isochrones.

Deployment: Azure Static Web Apps:
* Benefits: fast global distribution, low cost, automatic HTTPS, and seamless integration with GitHub CI/CD.
* The SPA model pairs perfectly with static hosting, as most logic runs client-side while fetching precomputed data.

# Backend
Azure Functions in C#:
* C# provides strong typing and mature tooling, which helps maintain reliability in serverless code.
* Serverless functions are cheap, scale automatically, and fit perfectly for event-driven tasks like serving requests for metadata or trigger-based operations.

# Data storage and caching
* Area metadata in Azure Table Storage
* Isochrone JSON blobs in Azure Blob Storage with CDN-friendly headers
Benefits: fast, cheap, globally distributed, and easy to update. Most of the data is relatively static, so caching reduces latency and costs.

# Isochrone computation

Real-time computation of walking-distance isochrones **is too expensive**: iterating over the pedestrian network for thousands of stops and stations would be slow.

**Solution**: offline precomputation using a CLI generator written in C#.
* Mapbox API handles the heavy lifting of isochrone calculation
* Overpass API retrieves the stops to analyze
* All results are stored in Blob Storage, ready to be served by the SPA.

This approach balances accuracy, performance, and cost without compromising interactivity.

# Key trade-offs and deliberate choices

* Avoided fully dynamic computation â†’ would be too slow and costly
* Chose serverless â†’ cheap, scalable, low ops overhead
* Avoided monolithic backend â†’ caching and offline computation are simpler with a clean separation
* Opted for TypeScript + Vue â†’ maintainable frontend without unnecessary complexity
* Leaflet â†’ lightweight and flexible for map visualization

Each choice reflects a trade-off between simplicity, performance, and maintainability.

> In the next post, Iâ€™ll talk about infrastructure + security + CI/CD.

**Looking for the proximity project repo and the online tool? **

* The [GitHub repo](https://github.com/nicolgit/proximity)
* The [Proximity project](https://proximity.duckiesfarm.com/) live

-----------------------------------------------

# linkedin

Building The Proximity Project seemed simple: compute walking-distance isochrones and display them interactively.

Scaling it to multiple cities, transport types, and interactive maps forced deliberate architectural choices:

* SPA frontend with Vue + TypeScript for reactive, maintainable interfaces
* Leaflet for lightweight, flexible map visualization
* Azure Static Web Apps for fast, CDN-backed frontend deployment
* C# Azure Functions backend, serverless, reliable, cheap to scale
* Offline precomputation of isochrones using Mapbox + Overpass API, stored in Azure Blob Storage

Each decision balanced performance, simplicity, and maintainability.

I wrote a short post diving into the architectural choices behind Proximity.

ðŸ‘‰ [link to blog post #3]

Previous posts in the series are linked in the comments.


[screenshot] diverso da quello precedente, piÃº tecnico (?)


Next up: Infrastructure + security + CI/CD.